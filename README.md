# Docserve

**Docserve** purpose is to make it easier to produce documentation for a project where you want to show different documentation to users with different roles.

**Warning (or not)**: much of this code produced with gpt 01-preview

This simple library solves the following problems:
- serve docs appropriate to the user's role, and only those docs.
- avoid having to create yml files for the docs created, just assume all the docs in a role folder are to be included

## Features

- **Role-Based Access Control**: Serve documentation to users based on their group memberships.
- **Reusable App**: Easily integrate into multiple Django projects.
- **MkDocs Integration**: Supports documentation generated by MkDocs, including themes like Material Design.
- **Easy Configuration**: Minimal setup required to get started.
- **Static Files Handling**: Manages static assets (CSS, JS) required by MkDocs documentation.

## Requirements

- Python 3.7 or higher
- Django 3.2 or higher
- MkDocs 1.4.2 or higher
- Optional: MkDocs Material theme if used

## Installation

1. **Install the Package**

   You can install `docserve` directly from your local source or via a package repository if published.

   ```bash
   pip install django-docserve

## Add to Installed Apps

In your project's settings.py, add docserve to the INSTALLED_APPS list:

    INSTALLED_APPS = [
        # ... other installed apps ...
        'docserve',
    ]

Point to the location of your source docs:

    DOCSERVE_DOCS_ROOT = os.path.join(BASE_DIR, 'docs')  # source .md files
    DOCSERVE_DOCS_SITE_ROOT = os.path.join(BASE_DIR, 'docs_site')  # where .html files will be put

or

    DOCSERVE_DOCS_ROOT = BASE_DIR / 'docs'    # source .md files
    DOCSERVE_DOCS_SITE_ROOT = BASE_DIR / 'docs_site'   # where .html files will be put


Include URLs

In your project's urls.py, include docserve URLs:

    from django.urls import path, include

    urlpatterns = [
         path('docs/', include(('docserve.urls', 'docserve'), namespace='docserve')),
         ...
    ]


## Add User Roles and Docs

The whole purpose of this library is to be able to supply different docs to different types of user.  The users role or roles can be based on the django groups they have or you can customise how you define this role.

If you want to use django groups and you don't already have the groups setup you can do that in the admin interface or programmatically like this:

    from django.contrib.auth.models import Group
    
    roles = ['admin', 'factory', 'distributor', 'support', 'user']
    for role in roles:
        Group.objects.get_or_create(name=role)
    Assign Users to Groups

Use the Django admin interface or scripts to assign users to the appropriate groups.

## Add your docs directory, role directory and docs

Create a docs directory wherever you specified in your setting DOCSERVE_DOCS_ROOT

For each role, create a subdirectory and add your .md files to that directory


## Build your Docs 

Each time you change the .md files, you will need to rebuild your docs.  To do this run two management commands:
          
        python manage.py generate_mkdocs_yml
        python manage.py build_docs

## Customisation

### Templates

To modify the index page, look at the page in docserve/templates/home_page.html and put your customised version into your project's templates directory under a docserve directory.

To customise the doc pages 

## URLs

If you don't want to use the /docs url, modify the url root in your urls.py, it should just work!

## Use a customised definition of role instead of django groups

coming soon...

## Customing the look and feel of the docs pages

Certainly! Here is the markdown-formatted text you can copy into a `.md` file:


### Customizing the Look and Feel of MkDocs-Generated Pages

You can customize the appearance of your MkDocs-generated documentation to better align with your project's branding and enhance user experience through your Django `settings.py` file. This approach allows you to define default and role-specific customizations without modifying the codebase.

#### 1. Define Customization Settings in `settings.py`

Add a new dictionary called `MKDOCS_CUSTOM_SETTINGS` to your `settings.py` file:

```python
# settings.py

# MkDocs customization settings (optional)
MKDOCS_CUSTOM_SETTINGS = {
    'default': {
        'theme': {
            'name': 'material',
            'palette': {
                'primary': 'blue',
                'accent': 'light blue'
            },
            'font': {
                'text': 'Open Sans',
                'code': 'Source Code Pro'
            },
            'icon': {
                'logo': 'cloud',
                'repo': 'github'
            }
        },
        'extra_css': [
            'overrides/extra.css'
        ],
        'extra_javascript': [
            'overrides/extra.js'
        ],
        'plugins': [
            'search',
            'minify'
        ]
    },
    'admin': {
        'theme': {
            'palette': {
                'primary': 'red',
                'accent': 'blue'
            }
        }
    },
    'user': {
        'theme': {
            'palette': {
                'primary': 'green',
                'accent': 'teal'
            }
        }
    }
}
```

- **Note**: The `'default'` key contains settings that apply to all roles unless overridden.
- **Role-Specific Customizations**: Define customizations for specific roles (e.g., `'admin'`, `'user'`).
- **It is up to you to install any plugins you use** - the minify plugin is not installed by default, eg. pip install mkdocs-minify-plugin


#### 2. How It Works

The `generate_mkdocs_yml.py` management command has been modified to read the `MKDOCS_CUSTOM_SETTINGS` from `settings.py` and apply them when generating the MkDocs configuration files for each role.

- **Default Configuration**: If `MKDOCS_CUSTOM_SETTINGS` is not defined, default settings are used.
- **Merging Settings**:
  - Default settings under `'default'` are applied first.
  - Role-specific settings override defaults where specified.

#### 3. Modify `generate_mkdocs_yml.py`

The management command uses a helper function `deep_update` to recursively merge dictionaries:

```python
def deep_update(self, original, update):
    """
    Recursively update a dictionary.
    """
    for key, value in update.items():
        if isinstance(value, dict) and isinstance(original.get(key), dict):
            self.deep_update(original[key], value)
        else:
            original[key] = value
```

This ensures that nested dictionaries in your settings are merged correctly.

Now you can rebuild your docs to see your changes:

      python manage.py generate_mkdocs_yml
      python manage.py build_docs



#### Additional Resources

- **MkDocs Configuration Options**: [MkDocs Configuration](https://www.mkdocs.org/user-guide/configuration/)
- **Material Theme Customization**: [Material Theme](https://squidfunk.github.io/mkdocs-material/setup/changing-the-colors/)
- **MkDocs Plugins**: [MkDocs Plugins](https://github.com/mkdocs/mkdocs/wiki/MkDocs-Plugins)
Certainly! Let's modify the code and documentation to allow users to customize how each role is defined, rather than relying solely on Django groups. This will make your application more flexible and adaptable to different permission systems.

---

## Overview

We'll introduce a new setting called `DOCSERVE_ROLE_DEFINITIONS` in `settings.py`. This setting will allow you to define how each role is determined for a user. You can specify role definitions using:

1. **Django Groups (Default Behavior):** The role name corresponds to a Django group name.
2. **Custom Functions:** Define a function that takes a `user` object and returns a boolean indicating whether the user has the role.
3. **Lambdas or Callable Objects:** Use lambdas or any callable that fits your needs.

We'll modify the `serve_docs` view and the `docs_home` view to use these customizable role definitions. We'll also update the documentation to reflect these changes.

---

## Step-by-Step Implementation

### Step 1: Define Role Definitions in `settings.py`

Add a new setting `DOCSERVE_ROLE_DEFINITIONS` to your `settings.py` file:

```python
# settings.py

DOCSERVE_ROLE_DEFINITIONS = {
    'admin': lambda user: user.is_superuser,
    'user': lambda user: user.is_authenticated and not user.is_superuser,
    # Add more roles as needed
}

# Optionally, you can define functions
def is_manager(user):
    return user.is_authenticated and user.groups.filter(name='manager').exists()

DOCSERVE_ROLE_DEFINITIONS['manager'] = is_manager
```

**Explanation:**

- The keys are role names (matching the documentation directories in `docs/`).
- The values are callables (functions or lambdas) that take a `user` object and return `True` if the user has the role.

### Step 2: Modify the `serve_docs` View

Update the `serve_docs` view in `docserve/views.py` to use the customizable role definitions:

```python
# docserve/views.py

import os
import mimetypes
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, HttpResponseForbidden, Http404
from django.conf import settings
from django.shortcuts import redirect

@login_required
def serve_docs(request, role, path=''):
    # Get the role definitions from settings
    role_definitions = getattr(settings, 'DOCSERVE_ROLE_DEFINITIONS', {})
    role_check = role_definitions.get(role)

    if role_check is None:
        return HttpResponseForbidden(f"Role '{role}' is not defined.")

    if not role_check(request.user):
        return HttpResponseForbidden("You do not have access to this documentation.")

    # Existing code to serve documentation...
    # [Include the updated serve_docs code from previous modifications]
    # (Ensure to handle asset files correctly)
```

**Explanation:**

- Retrieves `DOCSERVE_ROLE_DEFINITIONS` from `settings.py`.
- Looks up the role check function for the given role.
- If the role is not defined, returns a `403 Forbidden`.
- Calls the role check function with `request.user`.
- If the user does not have the role, returns a `403 Forbidden`.

### Step 3: Modify the `docs_home` View

Update the `docs_home` view to list only the documentation available to the user based on the custom role definitions:

```python
# docserve/views.py

from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.conf import settings

@login_required
def docs_home(request):
    role_definitions = getattr(settings, 'DOCSERVE_ROLE_DEFINITIONS', {})
    available_roles = []

    for role, role_check in role_definitions.items():
        if role_check(request.user):
            available_roles.append(role)

    return render(request, 'docserve/docs_home.html', {'roles': available_roles})
```

**Explanation:**

- Iterates over all roles defined in `DOCSERVE_ROLE_DEFINITIONS`.
- Checks if the user has each role.
- Collects the roles the user has into `available_roles`.
- Passes `available_roles` to the template.

### Step 4: Update Templates if Necessary

Ensure that your `docs_home.html` template uses the `roles` context variable correctly:

```html
<!-- docserve/templates/docserve/docs_home.html -->

<h1>Available Documentation</h1>
<ul>
    {% for role in roles %}
        <li><a href="{% url 'docserve:serve_docs_index' role=role %}">{{ role|title }} Documentation</a></li>
    {% endfor %}
</ul>
```

### Step 5: Provide Default Behavior

To maintain backward compatibility and provide default behavior, you can define default role checks that use Django groups when `DOCSERVE_ROLE_DEFINITIONS` is not specified:

```python
# docserve/views.py

def default_role_check(role):
    def check(user):
        return user.groups.filter(name=role).exists()
    return check
```

Then modify the `serve_docs` view:

```python
@login_required
def serve_docs(request, role, path=''):
    role_definitions = getattr(settings, 'DOCSERVE_ROLE_DEFINITIONS', {})
    role_check = role_definitions.get(role)

    if role_check is None:
        # Use default group-based role check
        role_check = default_role_check(role)

    if not role_check(request.user):
        return HttpResponseForbidden("You do not have access to this documentation.")

    # ... rest of the code ...
```

And similarly in `docs_home`:

```python
@login_required
def docs_home(request):
    role_definitions = getattr(settings, 'DOCSERVE_ROLE_DEFINITIONS', {})
    roles = [d for d in os.listdir(os.path.join(settings.BASE_DIR, 'docs')) if os.path.isdir(os.path.join(settings.BASE_DIR, 'docs', d))]
    available_roles = []

    for role in roles:
        role_check = role_definitions.get(role, default_role_check(role))
        if role_check(request.user):
            available_roles.append(role)

    return render(request, 'docserve/docs_home.html', {'roles': available_roles})
```

**Explanation:**

- If a role is not defined in `DOCSERVE_ROLE_DEFINITIONS`, the default behavior checks if the user belongs to a Django group with the same name as the role.
- This ensures existing setups continue to work without changes.

### Step 6: Update Documentation

Update your `README.md` or relevant documentation to explain how to customize role definitions.

---

## Updated Documentation Section

```markdown
### Customizing Role Definitions

By default, the `docserve` app determines user roles based on Django groups with the same name as the roles. However, you can customize how each role is defined by specifying role checks in your `settings.py` file.

#### Defining Custom Role Checks

Add a new setting `DOCSERVE_ROLE_DEFINITIONS` to your `settings.py`:

```python
# settings.py

DOCSERVE_ROLE_DEFINITIONS = {
    'admin': lambda user: user.is_superuser,
    'user': lambda user: user.is_authenticated and not user.is_superuser,
    'manager': lambda user: user.is_authenticated and user.groups.filter(name='manager').exists(),
    # Add more roles as needed
}
```

- **Keys**: Role names corresponding to the documentation directories in `docs/`.
- **Values**: Callables (functions or lambdas) that accept a `user` object and return `True` if the user has the role.

#### Examples

- **Using Lambdas**:

  ```python
  DOCSERVE_ROLE_DEFINITIONS = {
      'admin': lambda user: user.is_staff,
      'user': lambda user: user.is_authenticated,
  }
  ```

- **Using Functions**:

  ```python
  def is_premium_user(user):
      return user.is_authenticated and user.profile.is_premium

  DOCSERVE_ROLE_DEFINITIONS = {
      'premium': is_premium_user,
  }
  ```

#### Default Behavior

If `DOCSERVE_ROLE_DEFINITIONS` is not defined or a role is not specified, the app defaults to checking if the user belongs to a Django group with the same name as the role.

#### Updating Views

The `serve_docs` and `docs_home` views have been updated to use the custom role definitions. If a role is not defined in `DOCSERVE_ROLE_DEFINITIONS`, it falls back to the default group-based check.

#### Access Control Flow

1. **User Requests Documentation**: When a user requests documentation for a specific role.
2. **Role Check**: The app looks up the role in `DOCSERVE_ROLE_DEFINITIONS` and calls the associated function with `request.user`.
3. **Access Granted or Denied**:
   - **Granted**: If the function returns `True`, the user is allowed to access the documentation.
   - **Denied**: If the function returns `False`, the user receives a `403 Forbidden` response.

#### Example Use Cases

- **Role Based on User Attributes**:

  ```python
  DOCSERVE_ROLE_DEFINITIONS = {
      'beta_tester': lambda user: user.is_authenticated and user.profile.is_beta_tester,
  }
  ```

- **Complex Logic**:

  ```python
  def has_access(user):
      if not user.is_authenticated:
          return False
      # Custom logic
      return user.email.endswith('@example.com') and user.is_active

  DOCSERVE_ROLE_DEFINITIONS = {
      'special_access': has_access,
  }
  ```

#### Important Notes

- **Permissions are Evaluated at Runtime**: The role check functions are called each time a user requests documentation, ensuring up-to-date access control.
- **Security**: Ensure that your role check functions are secure and correctly implement your access control logic.

## Contributing

Contributions are welcome! Please submit issues and pull requests for any features or bug fixes.

### License
This project is licensed under the MIT License.
=
